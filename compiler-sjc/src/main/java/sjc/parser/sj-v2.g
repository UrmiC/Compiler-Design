header
{
package sjc.parser;
	
import java.io.Reader;

import java.math.BigInteger;
}

/**
* StaticJava parser.
* This class is automatically generated by ANTLR.
*
* @author <a href="mailto:robby@cis.ksu.edu">Robby</a>
*/
class SJParser extends Parser;

options
{
	k = 2; // use two lookahead, i.e., LL(2)
	defaultErrorHandler=false; // disable error handling
}

{ // add a static parse method
	public static void parse(Reader r) throws RecognitionException, TokenStreamException
	{
		new SJParser(new SJLexer(r)).compilationUnit();
	}
}


compilationUnit
	:	classDefinition
		EOF
	;

classDefinition
	:	"public" "class" IDENT LCURLY 
		mainMethodDeclaration
		( ("static" type IDENT SEMI) => 
			fieldDeclaration
		|	methodDeclaration )*
		RCURLY
	;

mainMethodDeclaration
	:	"public" "static" "void"
	    id1:IDENT 
	    { "main".equals(id1.getText()) }? 
	    LPAREN id2:IDENT LBRACK RBRACK 
	    { "String".equals(id2.getText()) }?
	    IDENT
	    RPAREN LCURLY methodBody RCURLY
	;
	
fieldDeclaration
	:	"static" type IDENT SEMI
	;
	
methodDeclaration
	:	"static" returnType IDENT
		LPAREN ( params )? RPAREN
		LCURLY methodBody RCURLY
	;
	
type
	: "boolean" | "int";
	
returnType
	:	"void" | type
	;
	
params
	:	param ( COMMA param )*
	;
	
param
	:	type IDENT
	;

methodBody
{
	boolean hasSeenStatement = false;
}
	:	( 
			(type IDENT SEMI) => 
			{ !hasSeenStatement }?
			localDeclaration 
		|	statement
			{ hasSeenStatement = true;}
		)*
	;

localDeclaration
	:	type IDENT SEMI
	;
	
statement
	:	(	assignStatement
		|	ifStatement
		|	whileStatement
		|	invokeExpStatement
		|	returnStatement
		)
	;
	
assignStatement
	:	IDENT ASSIGN exp SEMI
	;
	
ifStatement
	:	"if" LPAREN exp RPAREN
		LCURLY ( statement )* RCURLY
		( "else" LCURLY ( statement )*
		RCURLY )?
	;
	
whileStatement
	:	"while"	LPAREN exp RPAREN
		LCURLY ( statement )* RCURLY
	;
	
invokeExpStatement
	:	invokeExp SEMI
	;
	
returnStatement
	:	"return" ( exp )? SEMI
	;
	
exp
	:	logicalOrExp
	;
	
logicalOrExp
	:	logicalAndExp ( LOR logicalAndExp )*
	;
	
logicalAndExp
	:	equalityExp ( LAND equalityExp )*
	;
	
equalityExp
	:	relationalExp ( (NOT_EQUAL | EQUAL) relationalExp )*
	;
	
relationalExp
	:	additiveExp ( ( LT | GT | LE | GE ) additiveExp )*
	;
	
additiveExp
	:	multiplicativeExp ( ( PLUS | MINUS ) multiplicativeExp )*
	;
	
multiplicativeExp
	:	unaryExp ( ( STAR | DIV | MOD ) unaryExp )*
	;
	
unaryExp
	:	MINUS unaryExp
	|	PLUS unaryExp
	|	unaryExpNotPlusMinus
	;
	
unaryExpNotPlusMinus
	:	NOT unaryExp
	|	primaryExp
	;
	
primaryExp
	:	n:NUM_INT
		{ new BigInteger(n.getText()).bitLength() < 32 }?
	|	"true"
	|	"false"
	|	"null"
	|	LPAREN exp RPAREN
	|	invokeExp
	|	IDENT
	;
	
invokeExp
	:	( IDENT DOT )?
		IDENT LPAREN ( args )? RPAREN
	;
	
args
	:	exp ( COMMA exp )*
	;
	
/**
* StaticJava lexer.
* This class is automatically generated by ANTLR.
*
* @author <a href="mailto:robby@cis.ksu.edu">Robby</a>
*/
class SJLexer extends Lexer;

options
{
	k=2; // use two lookahead
	defaultErrorHandler=false; // disable error handling
}

LPAREN			:	'('		;
RPAREN			:	')'		;
LBRACK			:	'['		;
RBRACK			:	']'		;
LCURLY			:	'{'		;
RCURLY			:	'}'		;
COMMA			:	','		;
DOT				:	'.'		;
ASSIGN			:	'='		;
NOT				:	'!'		;
DIV				:	'/'		;
PLUS			:	'+'		;
MINUS			:	'-'		;
STAR			:	'*'		;
MOD				:	'%'		;
GT				:	'>'		;
LT				:	'<'		;
SEMI			:	';'		;
EQUAL			:	"=="	;
LE				:	"<="	;
NOT_EQUAL		:	"!="	;
GE				:	">="	;
LAND			:	"&&"	;
LOR				:	"||"	;

IDENT			:	( 'a'..'z' | 'A'..'Z' | '_' | '$' ) 
					( 'a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '$' )*	;

NUM_INT			:   ( '0' |	('1'..'9') ('0'..'9')* )	;

// Whitespace -- ignored
WS				:	( ' ' | '\t' | '\f'
						// handle newlines
						|	( options {generateAmbigWarnings=false;}
							:	"\r\n" | '\r' | '\n'
							)
							{ newline(); }
					)+
					// tell ANTLR to skip this WS token
					{ _ttype = Token.SKIP; }	;

