header
{
package sjc.parser;

import org.eclipse.jdt.core.dom.*;
	
import java.io.Reader;

import java.math.BigInteger;

import java.util.ArrayList;
}

/**
* StaticJava parser that builds Eclipse JDT AST.
* This class is automatically generated by ANTLR.
*
* @author <a href="mailto:robby@cis.ksu.edu">Robby</a>
*/
class ASTParser extends Parser;

options
{
	k = 2; // use two lookahead, i.e., LL(2)
	defaultErrorHandler=false; // disable error handling
}

{ // add a static parse method
	protected AST ast = AST.newAST(AST.JLS3);

	public static CompilationUnit parse(Reader r) throws RecognitionException, TokenStreamException
	{
		return new ASTParser(new ASTLexer(r)).compilationUnit();
	}
}

compilationUnit returns [CompilationUnit result = ast.newCompilationUnit()]
{
	TypeDeclaration td;
}
	:	td=classDefinition				{
											result.types().add(td);
										}
		EOF
	;

classDefinition returns [TypeDeclaration result = ast.newTypeDeclaration()]
{
	String className;
	MethodDeclaration md;
	FieldDeclaration fd;
} 
	:	"public"							{
												result.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
											}
		"class" id:IDENT LCURLY				{
												className = id.getText();
												result.setName(ast.newSimpleName(className));
											} 
		md=mainMethodDeclaration			{
												result.bodyDeclarations().add(md);
											}
		(	("static" type IDENT SEMI) =>
			fd=fieldDeclaration				{
												result.bodyDeclarations().add(fd);
											} 
		|
			md=methodDeclaration			{
												result.bodyDeclarations().add(md);
											} 
		)*
		RCURLY
	;

mainMethodDeclaration returns [MethodDeclaration result = ast.newMethodDeclaration()]
{
	String methodName;
	String typeName;
	String argName;
	SingleVariableDeclaration svd = ast.newSingleVariableDeclaration();
	Block b;
}
	:	"public"							{
												result.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
											}
		"static"							{
												result.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
											}
		"void" 								{
												result.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
											}
		id1:IDENT
		{"main".equals(id1.getText())}? 	{
												result.setName(ast.newSimpleName("main"));
											} 
		LPAREN id2:IDENT					
	    {"String".equals(id2.getText())}?
											{
												svd.setType(ast.newArrayType(ast.newSimpleType(ast.newSimpleName("String"))));
											}
		LBRACK RBRACK id3:IDENT 			{
												argName = id3.getText();
												svd.setName(ast.newSimpleName(argName));
												result.parameters().add(svd);
											}
		RPAREN LCURLY b=methodBody RCURLY	{
												result.setBody(b);
											}
	;
	
fieldDeclaration returns [FieldDeclaration result = null]
{
	VariableDeclarationFragment vdf = ast.newVariableDeclarationFragment();;
	result = ast.newFieldDeclaration(vdf);
	Type fieldType;
	String fieldName;
}
	:	"static"							{
												result.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
											} 
		fieldType=type						{
												result.setType(fieldType);
											}	
		id:IDENT							{
												vdf.setName(ast.newSimpleName(id.getText()));
											}
		SEMI
	;
	
methodDeclaration returns [MethodDeclaration result = ast.newMethodDeclaration()]
{
	Type retType;
	ArrayList<SingleVariableDeclaration> sdvs;
	Block b;
}
	:	"static" 							{
												result.modifiers().add(ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
											} 
		retType=returnType					{
												result.setReturnType2(retType);
											}
		id:IDENT LPAREN 					{
												result.setName(ast.newSimpleName(id.getText()));
											}
		( 
			sdvs=params						{
												result.parameters().addAll(sdvs);
											}
		)?
		RPAREN LCURLY b=methodBody RCURLY	{
												result.setBody(b);
											}
	;
	
type returns [Type result = null]
	:	"boolean"							{
												result = ast.newPrimitiveType(PrimitiveType.BOOLEAN);
											}
	|	"int"								{
												result = ast.newPrimitiveType(PrimitiveType.INT);
											}
	;
	
returnType returns [Type result = null]
	:	"void"								{
												result = ast.newPrimitiveType(PrimitiveType.VOID);
											} 	
	|	result=type
	;
	
params returns [ArrayList<SingleVariableDeclaration> result = new ArrayList<SingleVariableDeclaration>()]
{
	SingleVariableDeclaration svd;
}
	:	svd=param							{
												result.add(svd);	
											} 
		(	COMMA 
			svd=param						{
												result.add(svd);	
											}
		)*
	;
	
param returns [SingleVariableDeclaration result = ast.newSingleVariableDeclaration()]
{
	Type paramType;
	String paramName;
}
	:	paramType=type						{
												result.setType(paramType);
											}
		id:IDENT							{
												result.setName(ast.newSimpleName(id.getText()));
											}
	;
	
methodBody returns [Block result = ast.newBlock()]
{
	boolean hasSeenStatement = false;
	Statement s;
}
	:	( 
			(type IDENT SEMI) => 
			{ !hasSeenStatement }?
			s=localDeclaration 				{
												result.statements().add(s);
											}
		|	s=statement						{
												result.statements().add(s);
											}
			{ hasSeenStatement = true;}
		)*
	;
	
localDeclaration returns [VariableDeclarationStatement result = null]
{
	VariableDeclarationFragment vdf = ast.newVariableDeclarationFragment();
	result = ast.newVariableDeclarationStatement(vdf);
	Type localType;
}
	:	localType=type						{
												result.setType(localType);
											} 
		id:IDENT							{
												vdf.setName(ast.newSimpleName(id.getText()));
											}
		SEMI
	;
	
statement returns [Statement result = null]
	:	(	result=assignStatement
		|	result=ifStatement
		|	result=whileStatement
		|	result=invokeExpStatement
		|	result=returnStatement
		)
	;
	
assignStatement returns [ExpressionStatement result = null]
{
	String varName;
	Expression e;
	Assignment a = ast.newAssignment();
	result = ast.newExpressionStatement(a);
}
	:	id:IDENT 						{
											a.setLeftHandSide(ast.newSimpleName(id.getText()));
										}
		ASSIGN 
		e=exp 							{
											a.setRightHandSide(e);
										}
		SEMI
	;
	
ifStatement returns [IfStatement result = ast.newIfStatement()]
{
	Block thenStatement = ast.newBlock();
	result.setThenStatement(thenStatement);
	Block elseStatement = ast.newBlock();
	result.setElseStatement(elseStatement);
	Expression condExp;
	Statement s;
}
	:	"if" LPAREN condExp=exp RPAREN	{
											result.setExpression(condExp);
										}
		LCURLY
		( 
			s=statement 				{
											thenStatement.statements().add(s);
										}
		)* 
		RCURLY
		( "else" LCURLY 
			( 
				s=statement				{
											elseStatement.statements().add(s);
										}
			)* RCURLY )?
	;
	
whileStatement returns [WhileStatement result = ast.newWhileStatement()]
{
	Block whileBody = ast.newBlock();
	result.setBody(whileBody);
	Expression condExp;
	Statement s;
}
	:	"while"	LPAREN condExp=exp		{
											result.setExpression(condExp);
										}
		RPAREN LCURLY 
		(
			s=statement					{
											whileBody.statements().add(s);
										}
		)* RCURLY
	;
	
invokeExpStatement returns [ExpressionStatement result = null]
{
	MethodInvocation mi;
}
	:	mi=invokeExp SEMI				{
											result = ast.newExpressionStatement(mi);
										}
	;
	
returnStatement returns [ReturnStatement result = ast.newReturnStatement()]
{
	Expression e;
}
	:	"return" 
		( 
			e=exp						{
											result.setExpression(e);
										}
		)? SEMI
	;
	
exp returns [Expression result = null]
	:	result=logicalOrExp
	;
	
logicalOrExp returns [Expression result = null]
{
	Expression e;
}
	:	result=logicalAndExp			
		( 
			LOR	e=logicalAndExp			{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(InfixExpression.Operator.CONDITIONAL_OR);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
logicalAndExp returns [Expression result = null]
{
	Expression e;
}
	:	result=equalityExp 
		( 
			LAND e=equalityExp			{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(InfixExpression.Operator.CONDITIONAL_AND);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
equalityExp returns [Expression result = null]
{
	Expression e;
	InfixExpression.Operator op = null;
}
	:	result=relationalExp
		( 
			(
				NOT_EQUAL				{
											op = InfixExpression.Operator.NOT_EQUALS;
										}
			| 	EQUAL					{
											op = InfixExpression.Operator.EQUALS;
										}
			) 
			e=relationalExp				{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(op);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
relationalExp returns [Expression result = null]
{
	Expression e;
	InfixExpression.Operator op = null;
}
	:	result=additiveExp 
		(
			(	LT						{
											op = InfixExpression.Operator.LESS;
										}
			|	GT						{
											op = InfixExpression.Operator.GREATER;
										}
			|	LE						{
											op = InfixExpression.Operator.LESS_EQUALS;
										}
			|	GE						{
											op = InfixExpression.Operator.GREATER_EQUALS;
										}
			) 
			e=additiveExp				{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(op);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
additiveExp returns [Expression result = null]
{
	Expression e;
	InfixExpression.Operator op = null;
}
	:	result=multiplicativeExp
		(
			(	PLUS					{
											op = InfixExpression.Operator.PLUS;
										}
			|	MINUS					{
											op = InfixExpression.Operator.MINUS;
										}
			) 
			e=multiplicativeExp			{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(op);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
multiplicativeExp returns [Expression result = null]
{
	Expression e;
	InfixExpression.Operator op = null;
}
	:	result=unaryExp
		(
			(	STAR					{
											op = InfixExpression.Operator.TIMES;
										}
			|	DIV						{
											op = InfixExpression.Operator.DIVIDE;
										}
			|	MOD						{
											op = InfixExpression.Operator.REMAINDER;
										}
			)
			e=unaryExp					{
											InfixExpression ie = ast.newInfixExpression();
											ie.setLeftOperand(result);
											ie.setOperator(op);
											ie.setRightOperand(e); 
											result = ie;
										}
		)*
	;
	
unaryExp returns [Expression result = null]
{
	Expression e;
}
	:	MINUS e=unaryExp				{
											PrefixExpression pe = ast.newPrefixExpression();
											pe.setOperator(PrefixExpression.Operator.MINUS);
											pe.setOperand(e);
											result = pe;
										}
	|	PLUS e=unaryExp					{
											PrefixExpression pe = ast.newPrefixExpression();
											pe.setOperator(PrefixExpression.Operator.PLUS);
											pe.setOperand(e);
											result = pe;
										}
	|	result=unaryExpNotPlusMinus
	;
	
unaryExpNotPlusMinus returns [Expression result = null]
{
	Expression e;
}
	:	NOT e=unaryExp					{
											PrefixExpression pe = ast.newPrefixExpression();
											pe.setOperator(PrefixExpression.Operator.NOT);
											pe.setOperand(e);
											result = pe;
										}
	|	result=primaryExp
	;
	
primaryExp returns [Expression result = null]
{
	Expression e;
}
	:	n:NUM_INT						
		{ new BigInteger(n.getText()).bitLength() < 32 }?
										{
											NumberLiteral nl = ast.newNumberLiteral();
											nl.setToken(n.getText());
											result = nl;
										}
	|	"true"							{
											result = ast.newBooleanLiteral(true);
										}
	|	"false"							{
											result = ast.newBooleanLiteral(false);
										}
	|	LPAREN e=exp RPAREN				{
											ParenthesizedExpression pe = ast.newParenthesizedExpression();
											pe.setExpression(e);
											result = pe;
										}
	|	result=invokeExp
	|	id:IDENT						{
											result = ast.newSimpleName(id.getText());
										}
	;
	

invokeExp returns [MethodInvocation result = ast.newMethodInvocation()]
{
	String className = null;
	String methodName;
	ArrayList<Expression> es;
}
	:	( 
			id1:IDENT 					{
											className = id1.getText();
											result.setExpression(ast.newSimpleName(className));
										}
			DOT 
		)? 								
		id2:IDENT 						{
											methodName = id2.getText();
											result.setName(ast.newSimpleName(methodName));
										}
		LPAREN ( es=args 			
										{
											result.arguments().addAll(es);
										}
		)? RPAREN			
	;
	
args returns [ArrayList<Expression> result = new ArrayList<Expression>()]
{
	Expression e;
}
	:	e=exp							{
											result.add(e);
										}
		(
			COMMA e=exp					{
											result.add(e);
										}
		)*
	;
	
/**
* StaticJava lexer.
* This class is automatically generated by ANTLR.
*
* @author <a href="mailto:robby@cis.ksu.edu">Robby</a>
*/
class ASTLexer extends Lexer;

options
{
	k=2; // use two lookahed
	defaultErrorHandler=false; // disable error handling
}

LPAREN			:	'('		;
RPAREN			:	')'		;
LBRACK			:	'['		;
RBRACK			:	']'		;
LCURLY			:	'{'		;
RCURLY			:	'}'		;
COMMA			:	','		;
DOT				:	'.'		;
ASSIGN			:	'='		;
NOT				:	'!'		;
DIV				:	'/'		;
PLUS			:	'+'		;
MINUS			:	'-'		;
STAR			:	'*'		;
MOD				:	'%'		;
GT				:	'>'		;
LT				:	'<'		;
SEMI			:	';'		;
EQUAL			:	"=="	;
LE				:	"<="	;
NOT_EQUAL		:	"!="	;
GE				:	">="	;
LAND			:	"&&"	;
LOR				:	"||"	;

IDENT			:	( 'a'..'z' | 'A'..'Z' | '_' | '$' ) 
					( 'a'..'z' | 'A'..'Z' | '_' | '0'..'9' | '$' )*	;

NUM_INT			:   ( '0' |	('1'..'9') ('0'..'9')* )	;

// Whitespace -- ignored
WS				:	( ' ' | '\t' | '\f'
						// handle newlines
						|	( options {generateAmbigWarnings=false;}
							:	"\r\n" | '\r' | '\n'
							)
							{ newline(); }
					)+
					// tell ANTLR to skip this WS token
					{ _ttype = Token.SKIP; }	;


